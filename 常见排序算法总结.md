#常见的几种排序算法
[TOC]
## 冒泡排序
**基本思想：**
重复走访要排序的数列，一次比较两个元素，顺序错误则交换两个元素，直到没有再需要交换的元素。
**步骤：**
1. 比较相邻的元素，顺序错误就交换。
2. 对每对相邻的元素做同样的工作，从开始的第一对到结尾的最后一对。一趟工作下来，最后一个(第一个)元素则是最大(最小)的元素。
3. 针对所有的元素重复以上步骤，除了最后一个(第一个)。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对元素需要比较。
**代码实现：**
```java
public void bubbleSort(T[] nums){
    T tmp;
    for(int i=0; i<nums.length; i++){
        for(int j=i+1; j<nums.length; j++){
            if(nums[j].compareTo(nums[i]) < 0){
                tmp = nums[j];
                nums[j] = nums[i];
                nums[i] = tmp;
            }
        }
    }
}
```
冒泡排序是稳定算法，平均时间复杂度 $O(n^2)$, 空间复杂度 $O(1)$
**优化：**
+ 某一趟遍历如果没有数据交换，则说明已经排好序了，因此不需要再进行迭代了。使用一个标记记录这个状态即可。
+ 记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不再排序。因此通过这个位置就可以确定下次循环的范围了。

## 插入排序
**基本思想：**
排序开始默认第一个元素是一个有序序列；让第二个元素插入上述长为 1 的有序序列，使之成为一个长为 2 的有序序列；然后让第三个元素插入上述长为 2 的有序序列，使之成为一个长为 3 的有序序列；依此类推，最后让第 n 个元素插入上述长为 n-1 的有序序列，得到一个长为 n 的有序序列。
**步骤：**
1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素大于新元素，将该元素移到下一位置
4. 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤 2~5
**代码实现：**
```java
public void insertSort(T[] nums){
    T tmp;
    for(int i=1; i<nums.length; i++){
        tmp = nums[i];
        int j = i-1;
        while(j>=0 && tmp.compareTo(nums[j]) < 0){
            nums[j+1] = nums[j];
            j--;
        }
        nums[j+1] = tmp;
    }
}
```
## 选择排序
## 希尔排序
## 归并排序
## 堆排序
## 快速排序
## 计数排序
## 桶排序
## 基数排序